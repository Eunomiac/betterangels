import{gsap as t,Dragger as s,InertiaPlugin as e,MotionPathPlugin as r,U as i,XElem as n,XCircle as h,XItem as a,XDie as o,XSnap as p}from"./bundler.mjs";class u{constructor(t){this.t=t}i(...t){return t.reduce(((t,s=(t=>t))=>s(t)),this.t)}}export const MIX=(t=class{})=>new u(t);export const HasMotionPath=s=>class extends s{get path(){return this.h}set path(s){t.set(s,{o:-50,p:-50,transformOrigin:"50% 50%"}),$(s).attr("id",`${this.id}-motion-path`),this.h={id:`${this.id}-motion-path`,u:s,raw:r.g(s),l:i.P(i.m($(s).attr("d"),/(\d+)\s*z$/giu))},r.D(this.path.raw)}constructor(s,{path:e,S:r={},...n}={}){super(s,n);const[h]=this._.find(".motion-path");t.set(h,i.T({...this.constructor.O.C,...r},(t=>null!==t))),this.path=h}U(t){const{x:s,y:e,angle:i}=r.I(this.path.raw,t,!0);return{x:s,y:e,angle:i,M:t}}$(s,{M:e,x:r,y:n}={}){return e=e??t.N.normalize(0,360,i.A(this.H(s,{x:r??s.x,y:n??s.y}),[0,360])),this.U(e)}};export const HasSnapPath=s=>class extends(HasMotionPath(s)){get path(){const s=this;return{...super.path,get points(){return[...Array(s.k)].map(((e,r)=>{const i=s.U(t.N.v(0,s.k,0,1,r));return s.R(n.W,i)}))}}}set path(t){super.path=t,this.constructor.j=this}static get j(){return this.X=this.X??new Map}static set j(t){t.path.points.forEach((({x:s,y:e})=>{s=i.P(s),e=i.P(e),this.j.set({x:s,y:e},t)}))}static q(t){this.j.forEach(((s,e,r)=>{t.id===s.id&&r.delete(e)})),super.q(t)}get k(){return this.B=this.B??10}set k(t){this.B=t}};export const IsDraggable=t=>class extends t{get F(){return this.G}get J(){return this.F?.J}get K(){return this.L&&!this.J}get V(){return super.V||this.K||this.J}set V(t){super.V=t}get parent(){return super.parent}set parent(t){super.parent=t,this.F?.update()}constructor(t,s={}){super(t,s),this.Y()}Y(){const t=this;[this.G]=s.create(this.u,{type:"x,y",Z:!0,tt:this,st:2,et:400,rt:1e3,it(){return this.nt()},ht(t){return this.ot(t)},ut:{points:s=>t.gt(s)},ct(){return this.lt()},dt(){return this.Pt()},xt(){return this.yt()}})}nt(){this.L=!0}ot(){}gt(){}lt(){this.L=!1}Pt(){}yt(){}};export const SnapsToCircle=s=>class extends(IsDraggable(s)){get ut(){if(this.Dt)return null;const t=this;return{get Dt(){return t.St},get x(){return t.wt?.x},get y(){return t.wt?.y},get _t(){return{x:this.x,y:this.y}}}}get M(){return this.Dt.$(this).M}get Tt(){return this.Ct=this.Ct??this.options.Tt??1}set Tt(t){this.Ct=t}get Ot(){return this.Ut=this.Ut??0}set Ot(t){this.Ut=t}async ft(s,e=.5,r="power4.inOut"){if(!this.Dt)return Promise.reject();this.Ot=s;const{M:i}=this;return new Promise(((s,i)=>{t.to(this.u,{It:{path:this.Dt.path.u,Mt:[.5,.5],bt:!1,start:this.M,end:this.Ot},duration:e,tt:this,$t:r,Nt(){this.V=!0},At(){},Et(){this.V=!1,s()},Ht:i})}))}nt(...t){delete this.wt,delete this.St,delete this.kt,super.nt(...t),this.Dt&&(this.kt=this.Dt,this.Dt.vt(this)),this.parent=h.W,this.Rt()}ot(t,...s){super.ot(t,...s)}gt(t){if(!this.wt){super.gt(t);const{x:s,y:e,Dt:r}=h.Wt(t,this.kt);this.wt={x:s,y:e},this.St=r}return this.wt}lt(){super.lt(),this.St.jt(this)}yt(){super.yt(),this.Dt=this.St,this.Dt.zt(this)}};export const UpdateQueue=t=>class extends t{get Qt(){return this.Xt=this.Xt??{}}get qt(){return i.Bt(this.document.data,i.expand(this.Qt))}get Ft(){return this.qt}get Gt(){return this.qt}Jt(t){this.Xt={...this.Qt,...i.Kt(t)}}async Lt(t={}){return t={...this.Qt,...i.Kt(t)},delete this.Xt,this.document.update(t)}};